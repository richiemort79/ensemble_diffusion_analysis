//Example macro that does a diffusion analysis on a results table of tracking 
//data. The required format is as generated by the Manual Tracking plugin 
//http://rsbweb.nih.gov/ij/plugins/track/track.html
//assuming Results table column headings: Track > Slice > X > Y
//It requires many tracks and many time points!
//The analysis uses the time ensemble average method described in Charsooghi, MA et al 2011
//http://www.sciencedirect.com/science/article/pii/S0010465510003620

//Get number of tracks (nTracks)
//get the track numbers in an array to use as the index
track_number = list_no_repeats ("Results", "Track");

//get number of tracks (nTracks)
nTracks = track_number.length;

//Find the track length for each track - write track length to results table
//some variables
Track=1;
L_Track=0;

//work though tracks and determine length

for (i=0; i<track_number.length; i++){
//get the x, y values in an array
	frames = newArray();
	positions = newArray();
	for (j=0; j<nResults; j++) {

		if (getResultString("Track", j) == toString(track_number[i])){
			frames = Array.concat(frames, getResult("Frame", j));
			positions = Array.concat(positions, j);
			}
		}
		
//write length back to the results table
	Array.getStatistics(positions, min, max, mean, stdDev);
	pmin = min;
	pmax = max;
	Array.getStatistics(frames, min, max, mean, stdDev);
	fmin = min;
	fmax = max;

	for(z=pmin;z<=pmax;z++) {
      	setResult("T_Length", z , positions.length);
      }
      updateResults();
	
	}

//Index the tracks numerically will be the same as "Track" if strings are not used
index = 1;

for (l=0; l<nResults; l++) {
	if (l==0) {
		setResult("Index", l, index);
	}
	else if (getResultString("Track", l) == getResultString("Track",l-1)) {
		setResult("Index", l, index);
	}
	else if (getResult("Track", l) != getResult("Track",l-1)) {
		index = index+1;
		setResult("Index", l, index);
	}
}

//get last slice
maxslice = 0;
for (b=0; b<nResults(); b++) {
    if (getResult("Frame",b)>maxslice)
    {
     maxslice = getResult("Frame",b);
    	}
    	else{};
}

//get first slice
minslice = maxslice;
for (c=0; c<nResults(); c++) {
    if (getResult("Frame",c)<minslice)
    {
     minslice = getResult("Frame",c);
    	}
    	else{};
}

//The window sizes for analysis range from 1-step to - maxslice-1
//Calculate squared dispalcement from tracking data for all possible window sizes 

MSD = newArray();
time = newArray();
divide=0;
r_total=0;
dis2 = 0;

for (u=1; u<(maxslice); u++) {

for (i=0; i<nResults(); i++){
	if (getResult("Frame", i)<=u) {}
	
	else{ if (getResult("Index", i)>getResult("Index", i-u)) {}
	
	else { if (getResult("T_Length", i)>=u && getResult("Index", i-u)==getResult("Index", i)) {
	B9 = getResult("X", i);
	B8 = getResult("X", i-u);
	C9 = getResult("Y", i);
	C8 = getResult("Y", i-u);
	disx2 = (B9-B8)*(B9-B8);
	disy2 = (C9-C8)*(C9-C8);
	dis2 = (disx2 + disy2);
	r_total = r_total+dis2;	
	divide++;
			}	
		}
	}
}

time = Array.concat(time, u);	
MSD = Array.concat(MSD, (r_total)/divide);
r_total=0;
divide=0;
}

Fit.doFit("Straight Line", time, MSD);
intercept = d2s(Fit.p(0),6);
slope = d2s(Fit.p(1),6);
r2 = d2s(Fit.rSquared,3);
print("slope = "+slope);
print("intercept = "+intercept);
print("R^2 = "+r2);
Fit.plot();

function list_no_repeats (table, heading) {
//Returns an array of the entries in a column without repeats to use as an index

//Check whether the table exists
	if (isOpen(table)) {

//get the entries in the column without repeats
		no_repeats = newArray(getResultString(heading, 0));

		for (i=0; i<nResults; i++) {
			occurence = getResultString(heading, i);
			for (j=0; j<no_repeats.length; j++) {
				if (occurence != no_repeats[j]) {
					flag = 0;
				} else {
						flag = 1;
					}
				}
			
			if (flag == 0) {
				occurence = getResultString(heading, i);
				no_repeats = Array.concat(no_repeats, occurence);	
			}
		}
	} else {
		Dialog.createNonBlocking("Error");
		Dialog.addMessage("No table with the title "+table+" found.");
		Dialog.show();
	}
	return no_repeats;
}